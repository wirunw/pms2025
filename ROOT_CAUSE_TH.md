# สรุปสาเหตุปัญหาที่ทำให้ระบบล่มบน Railway

## 1. คำขอแดชบอร์ดถูกปฏิเสธเพราะไม่มีโทเคน
ก่อนหน้านี้สคริปต์ฝั่งเบราว์เซอร์เรียก `GET /api/dashboard/:period` โดยไม่แนบส่วนหัว `Authorization` ส่งผลให้เซิร์ฟเวอร์ตอบกลับเป็น `401 Unauthorized` และวงจรรีเฟรชอัตโนมัติของหน้าแดชบอร์ดทำให้คำขอถูกส่งซ้ำ ๆ จนดูเหมือนเซิร์ฟเวอร์ล่ม แก้ไขโดยให้ทุกคำขอที่ต้องใช้โทเคนแนบ `Bearer` token เสมอ เช่นใน `fetchDashboard` และตัวเรียก API อื่น ๆ ใน `index_sqlite.html` ที่ตรวจสอบและตั้งค่าเฮดเดอร์ก่อนยิงคำขอ

## 2. รหัสผ่านเก็บแบบข้อความเปล่า
โค้ดเก่าตรวจสอบรหัสผ่านด้วยการเทียบสตริงดิบ ๆ ทำให้ผู้ใช้ทุกคนรวมถึงแอดมินถูกเก็บในฐานข้อมูลแบบ plaintext ทั้งหมด เมื่อบริการถูกรันบน Railway ที่บังคับใช้ HTTPS ตัวกลาง ระหว่างรีเควสต์ที่ถูกยกเลิกกะทันหัน (เช่น health check) ทำให้โมดูล `raw-body` ขว้าง `BadRequestError` แล้วตอบ `502` ขณะล็อกอิน เพราะต้องอ่าน payload ซ้ำอีกครั้งเพื่อเทียบรหัสผ่านเดิมที่ยังไม่ถูกแฮช แก้ไขด้วยการใช้ `bcrypt` ในทุกจุดที่สร้างหรืออัปเดตรหัสผ่าน พร้อมอัปเกรดบัญชีเดิมอัตโนมัติเมื่อผู้ใช้ล็อกอินได้สำเร็จ เพื่อไม่ให้เกิดการเทียบซ้ำแบบ plaintext อีกต่อไป

## 3. การรวมข้อมูลแดชบอร์ดโหลดข้อมูลครั้งละมากเกินไป
อิมพลีเมนต์เดิมดึงข้อมูลทั้งหมดจากตาราง `Sales`, `Inventory`, `Formulary` แล้วประมวลผลด้วย JavaScript ส่งผลให้โหลดข้อมูลจำนวนมาก, ใช้เวลา CPU สูง และมีโอกาสถูกยกเลิกกลางคันระหว่างส่ง response ซึ่ง Railway มองว่าเป็นการ crash ได้ง่าย เวอร์ชันล่าสุดเปลี่ยนไปใช้คำสั่ง SQL แบบรวมผล (`COUNT`, `SUM`, `GROUP BY`) และ `LIMIT` เพื่อลดจำนวนเรคอร์ดที่ต้องอ่าน ทำให้คำขอสั้นลงและไม่ชนเพดานเวลาของแพลตฟอร์ม

---
### วิธีป้องกันไม่ให้เกิดซ้ำ
1. ให้มั่นใจว่าทุกคำขอที่ต้องยืนยันตัวตนดึงโทเคนจาก `localStorage` แล้วแนบไปกับส่วนหัวก่อนยิง API เสมอ
2. เก็บรหัสผ่านแบบแฮชด้วย `bcrypt` หรืออัลกอริทึมที่เหมาะสมในทันที อย่าเก็บเป็นข้อความเปล่า และไม่ควรย้อนกลับไปเทียบค่า plaintext อีก
3. เมื่อทำรายงานหรือสรุปข้อมูลจำนวนมาก ให้พยายามผลักภาระไปที่ฐานข้อมูลด้วยคำสั่ง `GROUP BY`, `LIMIT`, และเลือกเฉพาะคอลัมน์ที่จำเป็น เพื่อลดเวลารอและป้องกันการเชื่อมต่อถูกยกเลิก

